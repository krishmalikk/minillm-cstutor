{"instruction": "Quiz question on data structures:\n\nWhat is the time complexity of searching for an element in a balanced Binary Search Tree?\n\nA. O(1)\nB. O(log n)\nC. O(n)\nD. O(n log n)", "input": "", "output": "The correct answer is B. O(log n)\n\n**Explanation:**\n\nIn a balanced BST, the height of the tree is O(log n) where n is the number of nodes. During a search:\n\n1. Start at the root\n2. Compare the target with current node\n3. Go left if target is smaller, right if larger\n4. Repeat until found or reach a leaf\n\nSince we eliminate half the remaining nodes at each step (like binary search), and the tree has O(log n) levels, we make at most O(log n) comparisons.\n\n**Why other options are wrong:**\n- A. O(1) would require direct access (like hash tables)\n- C. O(n) is the worst case for an unbalanced BST\n- D. O(n log n) is the complexity of building a BST, not searching", "task_type": "quiz_question", "topic": "data_structures", "subtopic": "binary_search_tree", "difficulty": "beginner", "metadata": {"correct_answer": 1, "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"]}}
{"instruction": "Quiz question on algorithms:\n\nWhich sorting algorithm has the best average-case time complexity?\n\nA. Bubble Sort - O(n²)\nB. Merge Sort - O(n log n)\nC. Quick Sort - O(n log n)\nD. Both B and C have the same average-case complexity", "input": "", "output": "The correct answer is D. Both B and C have the same average-case complexity\n\n**Explanation:**\n\nBoth Merge Sort and Quick Sort have O(n log n) average-case time complexity, making them among the fastest comparison-based sorting algorithms.\n\n**Merge Sort:**\n- Always O(n log n) - guaranteed\n- Divides array in half, recursively sorts, then merges\n- Stable sort, requires O(n) extra space\n\n**Quick Sort:**\n- O(n log n) average, O(n²) worst case\n- Uses pivot to partition, recursively sorts partitions\n- In-place (O(log n) stack space), often faster in practice\n\n**Why Bubble Sort is slower:**\n- Compares adjacent elements, swaps if out of order\n- Always O(n²) average case\n- Simple but inefficient for large datasets\n\n**Key Insight:**\nO(n log n) is the theoretical lower bound for comparison-based sorting (proven via decision tree argument).", "task_type": "quiz_question", "topic": "algorithms", "subtopic": "sorting", "difficulty": "intermediate", "metadata": {"correct_answer": 3, "options": ["Bubble Sort - O(n²)", "Merge Sort - O(n log n)", "Quick Sort - O(n log n)", "Both B and C have the same average-case complexity"]}}
{"instruction": "Quiz question on operating systems:\n\nWhat is a deadlock in operating systems?\n\nA. A situation where a process uses too much CPU time\nB. A situation where two or more processes are unable to proceed because each is waiting for the other\nC. A memory leak that causes system slowdown\nD. A process that crashes unexpectedly", "input": "", "output": "The correct answer is B. A situation where two or more processes are unable to proceed because each is waiting for the other\n\n**Explanation:**\n\nA deadlock occurs when a set of processes are blocked, each waiting for a resource held by another process in the set. It's a circular wait with no resolution.\n\n**Classic Example - Dining Philosophers:**\n```\nPhilosopher 1 holds Fork A, waiting for Fork B\nPhilosopher 2 holds Fork B, waiting for Fork A\n→ Neither can proceed → Deadlock!\n```\n\n**Four Necessary Conditions (Coffman Conditions):**\n1. **Mutual Exclusion**: Resources can't be shared\n2. **Hold and Wait**: Process holds resources while waiting for others\n3. **No Preemption**: Resources can't be forcibly taken\n4. **Circular Wait**: Circular chain of processes waiting\n\n**Prevention Strategies:**\n- Break any one of the four conditions\n- Resource ordering (prevent circular wait)\n- Timeout and rollback\n\n**Why other options are wrong:**\n- A describes CPU starvation, not deadlock\n- C describes memory issues, unrelated\n- D describes a crash, deadlock processes don't crash - they freeze", "task_type": "quiz_question", "topic": "operating_systems", "subtopic": "deadlock", "difficulty": "intermediate", "metadata": {"correct_answer": 1, "options": ["CPU overuse", "Circular resource wait", "Memory leak", "Process crash"]}}
{"instruction": "Quiz question on machine learning:\n\nWhich of the following is NOT a common technique to prevent overfitting in neural networks?\n\nA. Dropout\nB. L2 Regularization\nC. Increasing model complexity\nD. Early stopping", "input": "", "output": "The correct answer is C. Increasing model complexity\n\n**Explanation:**\n\nIncreasing model complexity (more layers, more neurons) typically **increases** the risk of overfitting, not decreases it. A more complex model can memorize training data rather than learning general patterns.\n\n**Why the other options HELP prevent overfitting:**\n\n**A. Dropout:**\n- Randomly \"drops\" neurons during training (sets to 0)\n- Forces network to learn redundant representations\n- Acts like training an ensemble of smaller networks\n\n**B. L2 Regularization (Weight Decay):**\n- Adds penalty term: Loss + λ||w||²\n- Discourages large weights\n- Leads to simpler, smoother decision boundaries\n\n**D. Early Stopping:**\n- Monitor validation loss during training\n- Stop when validation loss starts increasing\n- Prevents the model from over-memorizing training data\n\n**The Bias-Variance Tradeoff:**\n- Simple models: High bias, low variance (underfitting)\n- Complex models: Low bias, high variance (overfitting)\n- Goal: Find the sweet spot\n\n**Other regularization techniques:**\n- Data augmentation\n- Batch normalization\n- L1 regularization (sparsity)", "task_type": "quiz_question", "topic": "machine_learning", "subtopic": "regularization", "difficulty": "intermediate", "metadata": {"correct_answer": 2, "options": ["Dropout", "L2 Regularization", "Increasing model complexity", "Early stopping"]}}
{"instruction": "Quiz question on networks:\n\nWhat is the main difference between TCP and UDP?\n\nA. TCP is faster than UDP\nB. UDP provides reliable, ordered delivery while TCP does not\nC. TCP provides reliable, ordered delivery while UDP does not\nD. TCP works on Layer 4, UDP works on Layer 3", "input": "", "output": "The correct answer is C. TCP provides reliable, ordered delivery while UDP does not\n\n**Explanation:**\n\n**TCP (Transmission Control Protocol):**\n- **Connection-oriented**: 3-way handshake before data transfer\n- **Reliable**: Acknowledges received packets, retransmits lost ones\n- **Ordered**: Reassembles packets in correct order\n- **Flow control**: Prevents sender from overwhelming receiver\n- **Congestion control**: Adjusts speed based on network conditions\n- Use cases: Web browsing (HTTP), email (SMTP), file transfer (FTP)\n\n**UDP (User Datagram Protocol):**\n- **Connectionless**: No handshake, just send\n- **Unreliable**: No acknowledgments or retransmission\n- **Unordered**: Packets may arrive out of order\n- **Fast**: No overhead from reliability mechanisms\n- Use cases: Video streaming, gaming, DNS, VoIP\n\n**Why other options are wrong:**\n- A: Actually, UDP is typically faster (less overhead)\n- B: This is backwards - TCP is reliable, UDP is not\n- D: Both TCP and UDP operate at Layer 4 (Transport Layer)\n\n**Quick Comparison:**\n| Feature | TCP | UDP |\n|---------|-----|-----|\n| Connection | Required | None |\n| Reliability | Guaranteed | Best-effort |\n| Speed | Slower | Faster |\n| Header size | 20+ bytes | 8 bytes |", "task_type": "quiz_question", "topic": "networks", "subtopic": "transport_layer", "difficulty": "beginner", "metadata": {"correct_answer": 2, "options": ["TCP is faster than UDP", "UDP provides reliable delivery", "TCP provides reliable delivery", "Different layers"]}}
{"instruction": "Quiz question on discrete math:\n\nHow many edges does a complete graph K₅ (with 5 vertices) have?\n\nA. 5\nB. 8\nC. 10\nD. 20", "input": "", "output": "The correct answer is C. 10\n\n**Explanation:**\n\nA complete graph Kₙ has an edge between every pair of distinct vertices.\n\n**Formula:**\nThe number of edges in Kₙ = C(n, 2) = n(n-1)/2\n\n**For K₅:**\nEdges = 5 × 4 / 2 = 20 / 2 = **10**\n\n**Intuitive reasoning:**\n- Each vertex connects to all other n-1 vertices\n- Total connections: n × (n-1) = 5 × 4 = 20\n- But each edge is counted twice (once from each endpoint)\n- So divide by 2: 20 / 2 = 10\n\n**Visual of K₅:**\n```\n      1\n     /|\\\n    / | \\\n   2--+--5\n   |\\ | /|\n   | \\|/ |\n   3-----4\n```\n\nAll vertices connected to all others.\n\n**General formula derivation:**\n- We choose 2 vertices from n to form an edge\n- This is \"n choose 2\" = C(n,2) = n!/(2!(n-2)!) = n(n-1)/2\n\n**Examples:**\n- K₃ (triangle): 3(2)/2 = 3 edges\n- K₄: 4(3)/2 = 6 edges\n- K₅: 5(4)/2 = 10 edges\n- K₆: 6(5)/2 = 15 edges", "task_type": "quiz_question", "topic": "discrete_math", "subtopic": "graph_theory", "difficulty": "beginner", "metadata": {"correct_answer": 2, "options": ["5", "8", "10", "20"]}}

