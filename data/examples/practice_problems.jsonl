{"instruction": "Solve the following data structures problem:\n\nImplement a function to check if a binary tree is a valid Binary Search Tree (BST).", "input": "", "output": "## Solution\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root: TreeNode) -> bool:\n    \"\"\"\n    Check if a binary tree is a valid BST.\n    \n    A valid BST has:\n    - Left subtree contains only nodes with values < current node\n    - Right subtree contains only nodes with values > current node\n    - Both subtrees are also valid BSTs\n    \"\"\"\n    def validate(node, min_val, max_val):\n        if node is None:\n            return True\n        \n        # Current node must be within valid range\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        # Recursively check subtrees with updated ranges\n        return (validate(node.left, min_val, node.val) and\n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))\n```\n\n## Explanation\n\nThe key insight is that we need to track the **valid range** for each node, not just compare with the immediate parent.\n\n### Why Simple Parent Comparison Fails\n\n```\n       5\n      / \\\n     1   6\n        / \\\n       3   7    ← 3 is less than 6, but violates BST!\n                  (3 should be > 5, the root)\n```\n\n### Algorithm\n\n1. Start with range (-∞, +∞)\n2. For left child: update max to parent's value\n3. For right child: update min to parent's value\n4. Each node must fall within its range\n\n### Complexity\n- **Time**: O(n) - visit each node once\n- **Space**: O(h) - recursion stack, h = tree height\n\n## Alternative: Inorder Traversal\n\n```python\ndef is_valid_bst_inorder(root):\n    \"\"\"BST inorder traversal produces sorted sequence.\"\"\"\n    prev = float('-inf')\n    \n    def inorder(node):\n        nonlocal prev\n        if not node:\n            return True\n        \n        if not inorder(node.left):\n            return False\n        \n        if node.val <= prev:\n            return False\n        prev = node.val\n        \n        return inorder(node.right)\n    \n    return inorder(root)\n```\n\n## Hints (if needed)\n\n1. Think about what constraints a BST places on each node\n2. The constraint isn't just about the parent - consider ancestors\n3. What range of values is valid for each position in the tree?", "task_type": "practice_problem", "topic": "data_structures", "subtopic": "binary_search_tree", "difficulty": "intermediate", "metadata": {"hints": ["Think about what constraints a BST places on each node", "The constraint isn't just about the parent - consider ancestors", "What range of values is valid for each position in the tree?"], "test_cases": [{"input": "[2,1,3]", "output": "true"}, {"input": "[5,1,4,null,null,3,6]", "output": "false"}]}}
{"instruction": "Solve the following algorithms problem:\n\nGiven an array of integers, find the length of the longest increasing subsequence (LIS).", "input": "", "output": "## Solution\n\n### Approach 1: Dynamic Programming O(n²)\n\n```python\ndef longest_increasing_subsequence(nums):\n    \"\"\"\n    Find length of longest increasing subsequence.\n    \n    Args:\n        nums: List of integers\n    \n    Returns:\n        Length of LIS\n    \"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    # dp[i] = length of LIS ending at index i\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n```\n\n### Approach 2: Binary Search O(n log n)\n\n```python\nimport bisect\n\ndef lis_binary_search(nums):\n    \"\"\"\n    Optimized LIS using binary search.\n    \n    Maintain a list 'tails' where tails[i] is the smallest\n    tail element for all increasing subsequences of length i+1.\n    \"\"\"\n    tails = []\n    \n    for num in nums:\n        # Find position to insert/replace\n        pos = bisect.bisect_left(tails, num)\n        \n        if pos == len(tails):\n            tails.append(num)  # Extend longest sequence\n        else:\n            tails[pos] = num   # Found smaller tail\n    \n    return len(tails)\n```\n\n## Explanation\n\n### DP Approach\n\nFor array `[10, 9, 2, 5, 3, 7, 101, 18]`:\n\n```\nIndex:  0   1   2   3   4   5   6    7\nNums:  10   9   2   5   3   7  101  18\nDP:     1   1   1   2   2   3   4    4\n\nLIS = [2, 3, 7, 101] or [2, 3, 7, 18], length = 4\n```\n\n### Binary Search Intuition\n\nThe `tails` array maintains the \"potential\" for extending subsequences:\n\n```\nProcess [10, 9, 2, 5, 3, 7, 101, 18]:\n\ntails after 10:  [10]\ntails after 9:   [9]        (9 replaces 10, smaller tail)\ntails after 2:   [2]        (2 replaces 9)\ntails after 5:   [2, 5]     (extend)\ntails after 3:   [2, 3]     (3 replaces 5)\ntails after 7:   [2, 3, 7]  (extend)\ntails after 101: [2, 3, 7, 101]\ntails after 18:  [2, 3, 7, 18]   (18 replaces 101)\n\nFinal length = 4\n```\n\n### Complexity Comparison\n\n| Approach | Time | Space |\n|----------|------|-------|\n| DP | O(n²) | O(n) |\n| Binary Search | O(n log n) | O(n) |\n\n## Hints (if needed)\n\n1. For DP: What does dp[i] represent? What's the recurrence?\n2. For optimization: Can you maintain something that helps you quickly find where to extend?\n3. Binary search: Think about maintaining the smallest possible values that allow future extensions", "task_type": "practice_problem", "topic": "algorithms", "subtopic": "dynamic_programming", "difficulty": "intermediate", "metadata": {"hints": ["For DP: What does dp[i] represent?", "Can you maintain something that helps you quickly find where to extend?", "Think about maintaining the smallest possible values"], "test_cases": [{"input": "[10,9,2,5,3,7,101,18]", "output": "4"}, {"input": "[0,1,0,3,2,3]", "output": "4"}]}}
{"instruction": "Solve the following operating systems problem:\n\nImplement a simple round-robin CPU scheduler simulation.", "input": "", "output": "## Solution\n\n```python\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass Process:\n    \"\"\"Represents a process in the system.\"\"\"\n    pid: int\n    arrival_time: int\n    burst_time: int\n    remaining_time: int = None\n    completion_time: int = None\n    turnaround_time: int = None\n    waiting_time: int = None\n    \n    def __post_init__(self):\n        if self.remaining_time is None:\n            self.remaining_time = self.burst_time\n\n\ndef round_robin_scheduler(processes: List[Process], time_quantum: int) -> List[Process]:\n    \"\"\"\n    Simulate Round-Robin CPU scheduling.\n    \n    Args:\n        processes: List of processes with arrival and burst times\n        time_quantum: Time slice for each process\n    \n    Returns:\n        List of completed processes with calculated metrics\n    \"\"\"\n    # Sort by arrival time\n    processes = sorted(processes, key=lambda p: p.arrival_time)\n    \n    ready_queue = deque()\n    current_time = 0\n    completed = []\n    process_idx = 0\n    n = len(processes)\n    \n    # Initialize - add first process\n    if processes:\n        ready_queue.append(processes[0])\n        process_idx = 1\n        current_time = processes[0].arrival_time\n    \n    execution_log = []\n    \n    while ready_queue or process_idx < n:\n        # If queue is empty but processes remain, jump to next arrival\n        if not ready_queue:\n            current_time = processes[process_idx].arrival_time\n            ready_queue.append(processes[process_idx])\n            process_idx += 1\n        \n        # Get next process\n        current_process = ready_queue.popleft()\n        \n        # Execute for time quantum or until completion\n        execute_time = min(time_quantum, current_process.remaining_time)\n        current_process.remaining_time -= execute_time\n        current_time += execute_time\n        \n        execution_log.append(f\"Time {current_time - execute_time}-{current_time}: P{current_process.pid}\")\n        \n        # Add newly arrived processes to queue\n        while process_idx < n and processes[process_idx].arrival_time <= current_time:\n            ready_queue.append(processes[process_idx])\n            process_idx += 1\n        \n        # Check if process completed\n        if current_process.remaining_time == 0:\n            current_process.completion_time = current_time\n            current_process.turnaround_time = (\n                current_process.completion_time - current_process.arrival_time\n            )\n            current_process.waiting_time = (\n                current_process.turnaround_time - current_process.burst_time\n            )\n            completed.append(current_process)\n        else:\n            # Process not finished, add back to queue\n            ready_queue.append(current_process)\n    \n    # Print execution log\n    print(\"Execution Timeline:\")\n    for log in execution_log:\n        print(f\"  {log}\")\n    \n    return completed\n\n\ndef calculate_metrics(processes: List[Process]):\n    \"\"\"Calculate and display scheduling metrics.\"\"\"\n    n = len(processes)\n    avg_turnaround = sum(p.turnaround_time for p in processes) / n\n    avg_waiting = sum(p.waiting_time for p in processes) / n\n    \n    print(\"\\nProcess Metrics:\")\n    print(\"-\" * 60)\n    print(f\"{'PID':<6}{'Arrival':<10}{'Burst':<8}{'Complete':<10}{'TAT':<8}{'Wait':<8}\")\n    print(\"-\" * 60)\n    \n    for p in sorted(processes, key=lambda x: x.pid):\n        print(f\"{p.pid:<6}{p.arrival_time:<10}{p.burst_time:<8}\"\n              f\"{p.completion_time:<10}{p.turnaround_time:<8}{p.waiting_time:<8}\")\n    \n    print(\"-\" * 60)\n    print(f\"Average Turnaround Time: {avg_turnaround:.2f}\")\n    print(f\"Average Waiting Time: {avg_waiting:.2f}\")\n\n\n# Example usage\nif __name__ == \"__main__\":\n    processes = [\n        Process(pid=1, arrival_time=0, burst_time=5),\n        Process(pid=2, arrival_time=1, burst_time=3),\n        Process(pid=3, arrival_time=2, burst_time=8),\n        Process(pid=4, arrival_time=3, burst_time=6),\n    ]\n    \n    time_quantum = 2\n    print(f\"Round Robin Scheduling (Quantum = {time_quantum})\\n\")\n    \n    completed = round_robin_scheduler(processes, time_quantum)\n    calculate_metrics(completed)\n```\n\n## Explanation\n\n### Round Robin Algorithm\n\n1. Each process gets a fixed time slice (quantum)\n2. If not finished, goes to back of ready queue\n3. Fair: No process waits too long\n4. Preemptive: Running process can be interrupted\n\n### Example Execution (Quantum = 2)\n\n```\nTime 0-2:   P1 runs (remaining: 3)\nTime 2-4:   P2 runs (remaining: 1)  \nTime 4-6:   P3 runs (remaining: 6)\nTime 6-8:   P4 runs (remaining: 4)\nTime 8-10:  P1 runs (remaining: 1)\nTime 10-11: P2 completes ✓\nTime 11-13: P3 runs (remaining: 4)\nTime 13-15: P4 runs (remaining: 2)\nTime 15-16: P1 completes ✓\nTime 16-18: P3 runs (remaining: 2)\nTime 18-20: P4 completes ✓\nTime 20-22: P3 completes ✓\n```\n\n### Key Formulas\n\n- **Turnaround Time** = Completion Time - Arrival Time\n- **Waiting Time** = Turnaround Time - Burst Time\n\n### Choosing Time Quantum\n\n- **Too small**: High context switch overhead\n- **Too large**: Degrades to FCFS\n- **Rule of thumb**: 80% of CPU bursts should be < quantum\n\n## Hints (if needed)\n\n1. Use a queue to manage ready processes\n2. Track remaining time for each process\n3. Handle new arrivals during execution", "task_type": "practice_problem", "topic": "operating_systems", "subtopic": "cpu_scheduling", "difficulty": "intermediate", "metadata": {"hints": ["Use a queue to manage ready processes", "Track remaining time for each process", "Handle new arrivals during execution"]}}
{"instruction": "Solve the following algorithms problem:\n\nImplement Dijkstra's algorithm to find the shortest path in a weighted graph.", "input": "", "output": "## Solution\n\n```python\nimport heapq\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple, Optional\n\n\ndef dijkstra(\n    graph: Dict[int, List[Tuple[int, int]]],\n    start: int,\n    end: Optional[int] = None\n) -> Tuple[Dict[int, int], Dict[int, Optional[int]]]:\n    \"\"\"\n    Find shortest paths from start node using Dijkstra's algorithm.\n    \n    Args:\n        graph: Adjacency list {node: [(neighbor, weight), ...]}\n        start: Starting node\n        end: Optional target node (returns early if found)\n    \n    Returns:\n        distances: Dict of {node: shortest_distance}\n        predecessors: Dict for path reconstruction\n    \"\"\"\n    # Initialize distances with infinity\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    # Track predecessors for path reconstruction\n    predecessors = {node: None for node in graph}\n    \n    # Priority queue: (distance, node)\n    pq = [(0, start)]\n    \n    # Track visited nodes\n    visited = set()\n    \n    while pq:\n        current_dist, current_node = heapq.heappop(pq)\n        \n        # Skip if already processed\n        if current_node in visited:\n            continue\n        \n        visited.add(current_node)\n        \n        # Early termination if we found the target\n        if end is not None and current_node == end:\n            break\n        \n        # Skip if we found a better path already\n        if current_dist > distances[current_node]:\n            continue\n        \n        # Explore neighbors\n        for neighbor, weight in graph[current_node]:\n            if neighbor in visited:\n                continue\n                \n            new_dist = current_dist + weight\n            \n            # Found a shorter path\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                predecessors[neighbor] = current_node\n                heapq.heappush(pq, (new_dist, neighbor))\n    \n    return distances, predecessors\n\n\ndef reconstruct_path(\n    predecessors: Dict[int, Optional[int]],\n    start: int,\n    end: int\n) -> List[int]:\n    \"\"\"\n    Reconstruct the shortest path from start to end.\n    \n    Args:\n        predecessors: Dict from dijkstra()\n        start: Starting node\n        end: Ending node\n    \n    Returns:\n        List of nodes in the shortest path\n    \"\"\"\n    path = []\n    current = end\n    \n    while current is not None:\n        path.append(current)\n        current = predecessors[current]\n    \n    path.reverse()\n    \n    # Verify path starts at start\n    if path[0] != start:\n        return []  # No path exists\n    \n    return path\n\n\n# Example usage and visualization\nif __name__ == \"__main__\":\n    # Create a weighted graph\n    # Graph visualization:\n    #       7\n    #   1 -----> 2\n    #   |  \\     |\n    #  2|   \\3   |1\n    #   v    \\   v\n    #   3 ---> 4 --> 5\n    #      1     2\n    \n    graph = defaultdict(list)\n    edges = [\n        (1, 2, 7),   # 1 -> 2, weight 7\n        (1, 3, 2),   # 1 -> 3, weight 2\n        (1, 4, 3),   # 1 -> 4, weight 3\n        (2, 5, 1),   # 2 -> 5, weight 1\n        (3, 4, 1),   # 3 -> 4, weight 1\n        (4, 5, 2),   # 4 -> 5, weight 2\n    ]\n    \n    for u, v, w in edges:\n        graph[u].append((v, w))\n        # Add nodes that only appear as destinations\n        if v not in graph:\n            graph[v] = []\n    \n    start, end = 1, 5\n    \n    distances, predecessors = dijkstra(graph, start)\n    path = reconstruct_path(predecessors, start, end)\n    \n    print(f\"Shortest distances from node {start}:\")\n    for node, dist in sorted(distances.items()):\n        print(f\"  Node {node}: {dist}\")\n    \n    print(f\"\\nShortest path from {start} to {end}:\")\n    print(f\"  Path: {' -> '.join(map(str, path))}\")\n    print(f\"  Distance: {distances[end]}\")\n```\n\n## Explanation\n\n### Algorithm Steps\n\n1. **Initialize**: Set distance to start = 0, all others = ∞\n2. **Priority Queue**: Always process the unvisited node with smallest distance\n3. **Relaxation**: If `dist[u] + weight(u,v) < dist[v]`, update dist[v]\n4. **Repeat**: Until all nodes visited or target found\n\n### Visual Trace\n\n```\nStep 1: Visit node 1 (dist=0)\n  Update: node 2 (dist=7), node 3 (dist=2), node 4 (dist=3)\n  PQ: [(2,3), (3,4), (7,2)]\n\nStep 2: Visit node 3 (dist=2)\n  Update: node 4 (dist=2+1=3, no change - already 3)\n  PQ: [(3,4), (7,2)]\n\nStep 3: Visit node 4 (dist=3)\n  Update: node 5 (dist=3+2=5)\n  PQ: [(5,5), (7,2)]\n\nStep 4: Visit node 5 (dist=5) - TARGET FOUND!\n  Path: 1 -> 4 -> 5, Distance: 5\n```\n\n### Complexity\n\n| Implementation | Time | Space |\n|---------------|------|-------|\n| Binary Heap | O((V + E) log V) | O(V) |\n| Fibonacci Heap | O(E + V log V) | O(V) |\n\n### Key Properties\n\n- Works only with **non-negative weights**\n- **Greedy**: Always picks minimum distance node\n- **Optimal**: Guarantees shortest paths\n\n## Hints (if needed)\n\n1. Use a min-heap (priority queue) for efficiency\n2. The greedy choice is provably optimal for non-negative weights\n3. To get the actual path, track predecessors during relaxation", "task_type": "practice_problem", "topic": "algorithms", "subtopic": "graph_algorithms", "difficulty": "intermediate", "metadata": {"hints": ["Use a min-heap for efficiency", "Track predecessors to reconstruct path", "Works only with non-negative weights"]}}
{"instruction": "Solve the following discrete math problem:\n\nProve that the set of all finite subsets of natural numbers is countable.", "input": "", "output": "## Solution\n\n### Claim\nThe set F of all finite subsets of ℕ (natural numbers) is countably infinite.\n\n### Proof Strategy\nWe'll construct an explicit bijection between F and ℕ using binary representation.\n\n### Proof\n\n**Key Insight**: Every finite subset S ⊆ ℕ can be encoded as a natural number.\n\n**Encoding Function** f: F → ℕ\n\nFor a finite subset S = {a₁, a₂, ..., aₖ} ⊆ ℕ:\n\n```\nf(S) = 2^a₁ + 2^a₂ + ... + 2^aₖ\n```\n\nFor the empty set: f(∅) = 0\n\n**Examples**:\n- f({0}) = 2⁰ = 1\n- f({1}) = 2¹ = 2  \n- f({0, 1}) = 2⁰ + 2¹ = 3\n- f({2}) = 2² = 4\n- f({0, 2}) = 2⁰ + 2² = 5\n- f({1, 2}) = 2¹ + 2² = 6\n- f({0, 1, 2}) = 2⁰ + 2¹ + 2² = 7\n\n**Why This is a Bijection**:\n\n1. **Injective (one-to-one)**: Each natural number has a unique binary representation. Different subsets → different sums of powers of 2.\n\n2. **Surjective (onto)**: Every natural number n can be written in binary, corresponding to some finite subset.\n\n**Formal Argument**:\n\nThe binary representation of any n ∈ ℕ is:\n```\nn = Σ bᵢ · 2ⁱ  where bᵢ ∈ {0, 1}\n```\n\nThe corresponding subset is:\n```\nS = {i : bᵢ = 1}\n```\n\nSince n is finite, only finitely many bᵢ = 1, so S is finite.\n\n### Constructive Enumeration\n\n```python\ndef nth_finite_subset(n):\n    \"\"\"Convert natural number n to its corresponding finite subset.\"\"\"\n    subset = set()\n    position = 0\n    while n > 0:\n        if n & 1:  # Check if bit is set\n            subset.add(position)\n        n >>= 1\n        position += 1\n    return subset\n\ndef subset_to_number(subset):\n    \"\"\"Convert finite subset to its corresponding natural number.\"\"\"\n    return sum(2**i for i in subset) if subset else 0\n\n# Verify bijection\nfor n in range(16):\n    S = nth_finite_subset(n)\n    n_back = subset_to_number(S)\n    print(f\"{n} <-> {S} <-> {n_back}\")\n```\n\n**Output**:\n```\n0 <-> {} <-> 0\n1 <-> {0} <-> 1\n2 <-> {1} <-> 2\n3 <-> {0, 1} <-> 3\n4 <-> {2} <-> 4\n...\n```\n\n### Corollary\n\nSince we established a bijection f: F → ℕ, and ℕ is countably infinite, F is also countably infinite.\n\n### Note\n\nThis contrasts with P(ℕ), the set of ALL subsets (including infinite ones), which is **uncountable** by Cantor's diagonal argument.\n\n## Alternative Proof Sketch\n\nPartition F by subset size:\n- F₀ = {∅} — 1 set\n- F₁ = {{0}, {1}, {2}, ...} — countable\n- F₂ = {{0,1}, {0,2}, ...} — countable\n- Fₖ = all k-element subsets — countable\n\nF = F₀ ∪ F₁ ∪ F₂ ∪ ...\n\nA countable union of countable sets is countable. ∎", "task_type": "practice_problem", "topic": "discrete_math", "subtopic": "set_theory", "difficulty": "advanced", "metadata": {"hints": ["Think about binary representation", "Each natural number encodes a unique subset", "Consider the bijection between binary strings and subsets"]}}

